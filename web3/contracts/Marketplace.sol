// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "./GameItems.sol";
import "lib/chainlink/contracts/src/v0.8/vrf/VRFConsumerBase.sol";

contract Marketplace is AccessControl, VRFConsumerBase {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    IERC20 public arcaneToken;
    GameItems public gameItems;

    uint256 public mysteryBoxPrice;
    bytes32 internal keyHash;
    uint256 internal fee;

    mapping(bytes32 => address) private requestToPlayer;

    event ItemPurchased(address indexed buyer, uint256 itemId, uint256 amount);
    event MysteryBoxPurchased(address indexed buyer, bytes32 requestId);
    event MysteryBoxOpened(address indexed player, uint256 professorCardId);

    constructor(
        address _arcaneToken,
        address _gameItems,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        uint256 _fee
    ) VRFConsumerBase(_vrfCoordinator, _linkToken) {
        arcaneToken = IERC20(_arcaneToken);
        gameItems = GameItems(_gameItems);
        keyHash = _keyHash;
        fee = _fee;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);

        mysteryBoxPrice = 100 * 10**18; // Default price: 100 ArcaneTokens
    }

    /// @notice Set the price of the mystery box
    /// @param price The new price in ArcaneTokens
    function setMysteryBoxPrice(uint256 price) external onlyRole(ADMIN_ROLE) {
        mysteryBoxPrice = price;
    }

    /// @notice Purchase an item from the marketplace
    /// @param itemId The ID of the item to purchase
    /// @param amount The amount of the item to purchase
    function purchaseItem(uint256 itemId, uint256 amount) external {
        (, , , uint256 price) = gameItems.getItem(itemId);
        uint256 totalCost = price * amount;

        require(
            arcaneToken.transferFrom(msg.sender, address(this), totalCost),
            "Payment failed"
        );

        gameItems.mintItem(msg.sender, itemId, amount);

        emit ItemPurchased(msg.sender, itemId, amount);
    }

    /// @notice Purchase a mystery box
    function purchaseMysteryBox() external {
        require(
            arcaneToken.transferFrom(msg.sender, address(this), mysteryBoxPrice),
            "Payment failed"
        );

        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");

        bytes32 requestId = requestRandomness(keyHash, fee);
        requestToPlayer[requestId] = msg.sender;

        emit MysteryBoxPurchased(msg.sender, requestId);
    }

    /// @notice Fulfill the randomness request for the mystery box
    /// @param requestId The ID of the randomness request
    /// @param randomness The random number generated by Chainlink VRF
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        address player = requestToPlayer[requestId];
        require(player != address(0), "Invalid request ID");

        uint256 professorCardId = (randomness % 10) + 1; // Random ID between 1 and 10
        gameItems.mintItem(player, professorCardId, 1);

        emit MysteryBoxOpened(player, professorCardId);
    }

    /// @notice Withdraw ArcaneTokens from the contract
    /// @param to The address to send the tokens to
    /// @param amount The amount of tokens to withdraw
    function withdrawArcaneTokens(address to, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(arcaneToken.transfer(to, amount), "Withdrawal failed");
    }

    /// @notice Withdraw LINK tokens from the contract
    /// @param to The address to send the LINK tokens to
    /// @param amount The amount of LINK tokens to withdraw
    function withdrawLink(address to, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(LINK.transfer(to, amount), "Withdrawal failed");
    }
}